[link: Heuristic](https://easyai.tech/ai-definition/heuristic/)

启发式算法（heuristic)是**相对于最优化算法**提出的。

一个问题的最优算法求得该问题每个实例的最优解。



启发式算法可以这样定义：

一个**基于直观或经验构造的算法**，在可接受的花费（指计算时间和空间）下给出**待解决组合优化问题每一个实例的一个可行解**，该可行解与最优解的偏离程度**一般不能被预计**。

- 现阶段，启发式算法以仿自然体算法为主，主要有蚁群算法、模拟退火法、**神经网络**等。





在计算机科学，人工智能和数学优化中，启发式是一种技术，用于==在经典方法太慢时更快地解决问题==，或者用于==在经典方法中找到近似解找不到任何确切的解决方案==。

这是通过交易速度的最佳性，完整性，准确性或精确度来实现的。

在某种程度上，它可以被认为是一种捷径。

一个启发式的功能，也简称为启发，是一个功能是居替代搜索算法根据现有的资料，以决定跟随哪一个分支，在每个分支的一步。

例如，它**可能接近确切的解决方案**。



---

[Wiki](https://zh.wikipedia.org/wiki/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95)

## 启发式算法

计算机科学的两大基础目标，就是发现可[证明](https://zh.wikipedia.org/wiki/證明)其[运行效率](https://zh.wikipedia.org/wiki/執行期)良好且可得[最佳解](https://zh.wikipedia.org/wiki/最优化)或次佳解的[算法](https://zh.wikipedia.org/wiki/演算法)。

而**启发式**算法则试图一次提供一个或全部目标。例如：

- 它常能发现**很不错的解**，但也没办法证明它不会得到较坏的解；

- 它通常可在**合理时间解出答案**，但也没办法知道它是否每次都可以这样的速度求解。

有时候人们会发现在某些特殊情况下，启发式算法会得到很坏的答案或效率极差，然而造成那些特殊情况的数据结构，也许永远不会在现实世界出现。

因此现实世界中启发式算法很**常用来解决问题**。启发式算法处理许多实际问题时通常可以在合理时间内得到不错的答案。

有一类的通用启发式策略称为[元启发算法](https://zh.wikipedia.org/wiki/元启发算法)（metaheuristic），通常使用==随机数搜索技巧==。

他们可以应用在非常广泛的问题上，但不能保证效率。



## 启发式算法与最短路径问题

所谓的[最短路径](https://zh.wikipedia.org/wiki/最短路径)问题有很多种意思，在这里**启发式**指的是在一个[搜索树](https://zh.wikipedia.org/wiki/树的遍历)的节点上定义的函数$h(n)$)，用于评估从此节点到目标节点成本最小的[路径](https://zh.wikipedia.org/wiki/路徑)。

启发式通常用于**信息充分**的搜索算法，例如[最好优先](https://zh.wikipedia.org/w/index.php?title=最好优先&action=edit&redlink=1)[贪心算法](https://zh.wikipedia.org/wiki/貪婪演算法)与[A*](https://zh.wikipedia.org/wiki/A*)。

最好优先贪心算法会为启发式函数选择最低代价的节点；A\*则会为$g(n)+h(n)$选择最低代价的节点，此$g(n)$是从起始节点到目前节点的路径的确实代价。

如果$h(n)$是**可接受的**（admissible）意即$h(n)$未曾付出超过达到目标的代价，则A*一定会找出[最佳解](https://zh.wikipedia.org/wiki/最佳化)。



最能感受到启发式算法好处的经典问题是[n-puzzle](https://zh.wikipedia.org/wiki/N-puzzle)。

此问题在计算错误的拼图图形，与计算任两块拼图的[曼哈顿距离](https://zh.wikipedia.org/wiki/曼哈頓距離)的总和以及它距离目的有多远时，使用了本算法。

注意，上述两条件都必须在可接受的范围内。





### 启发式算法对运算性能的影响

任何的搜索问题中，每个节点都有$b$个选择以及到达目标的深度$d$，一个毫无技巧的算法通常都要搜索$b^d$个节点才能找到答案。

启发式算法借由使用某种切割机制降低了分支因子（branching factor）以改进搜索效率，由$b^d$降到较低的$b'$。

分叉率可以用来定义启发式算法的偏序关系，例如：若在一个n节点的搜索树上，$h_1(n)$的分叉率较$h_2(n)$低，则$h_1(n) < h_2(n)$

启发式为每个要解决特定问题的搜索树的**每个节点提供了较低的分叉率**，因此它们拥有较佳效率的计算能力。

- 比如A*算法：启发函数h(n)



### 找寻新的启发式算法

如何找到一个分叉率较少又通用的合理启发式算法，已被[人工智能](https://zh.wikipedia.org/wiki/人工智慧)社区深入探究过。他们使用几种常见技术：

- 部分问题的解答的代价通常可以评估解决整个问题的代价，通常很合理。例如一个10-puzzle拼盘，解题的代价应该与将1到5的方块移回正确位置的代价差不多。通常解题者会先创建一个存储部分问题所需代价的[模式数据库](https://zh.wikipedia.org/w/index.php?title=模式資料庫&action=edit&redlink=1)（pattern database）以评估问题。

- 解决较易的**近似问题**通常可以拿来合理评估原先问题。
  - 例如[曼哈顿距离](https://zh.wikipedia.org/wiki/曼哈頓距離)是一个简单版本的n-puzzle问题，因为我们假设可以独立移动一个方块到我们想要的位置，而暂不考虑会移到其他方块的问题。

- 给我们一群合理的启发式函数$h_1(n),...h_i(n)$，而函数$h(n) = max\{h_1(n),...h_i(n) \}$则是个可预测这些函数的启发式函数。

一个在1993年由[A.E. Prieditis](https://zh.wikipedia.org/w/index.php?title=A.E._Prieditis&action=edit&redlink=1)写出的程序ABSOLVER就运用了这些技术，这程序可以自动为问题产生启发式算法。

ABSOLVER为[8-puzzle](https://zh.wikipedia.org/wiki/N-puzzle)产生的启发式算法优于任何先前存在的！

而且它也发现了第一个有用的解[魔术方块](https://zh.wikipedia.org/wiki/魔術方塊)的启发式程序。

