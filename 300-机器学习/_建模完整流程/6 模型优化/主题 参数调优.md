# 传统或手动调参

Dr.Mukesh Rao的超参数样本清单：

![img](https://raw.githubusercontent.com/DaiDuncan/PicUploader/main/img2/20210318160237.jpeg)

```python
#importing required libraries
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold , cross_val_score
from sklearn.datasets import load_wine

wine = load_wine()
X = wine.data
y = wine.target

#splitting the data into train and test set
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size = 0.3,random_state = 14)

#declaring parameters grid
k_value = list(range(2,11))
algorithm = ['auto','ball_tree','kd_tree','brute']
scores = []
best_comb = []
kfold = KFold(n_splits=5)

#hyperparameter tunning
for algo in algorithm:
  for k in k_value:
    knn = KNeighborsClassifier(n_neighbors=k,algorithm=algo)
    results = cross_val_score(knn,X_train,y_train,cv = kfold)	#k折交叉验证

    print(f'Score:{round(results.mean(),4)} with algo = {algo} , K = {k}')
    scores.append(results.mean())
    best_comb.append((k,algo))

best_param = best_comb[scores.index(max(scores))]
print(f'\nThe Best Score : {max(scores)}')
print(f"['algorithm': {best_param[1]} ,'n_neighbors': {best_param[0]}]")
```



## 缺陷

1. 不能保证得到最佳的参数组合。

2. 这是一种反复试验的方法，因此会消耗更多的时间。



# 网格搜索Grid Search

类似于手动调优，为网格中指定的所有给定超参数值的每个排列建立模型，并评估和选择最佳模型

```python
from sklearn.model_selection import GridSearchCV

knn = KNeighborsClassifier()
grid_param = { 'n_neighbors' : list(range(2,11)) , 
              'algorithm' : ['auto','ball_tree','kd_tree','brute'] }

grid = GridSearchCV(knn,grid_param,cv = 5)
grid.fit(X_train,y_train)

#best parameter combination
grid.best_params_

#Score achieved with best parameter combination
grid.best_score_

#all combinations of hyperparameters
grid.cv_results_['params']

#average scores of cross-validation
grid.cv_results_['mean_test_score']
```



## 缺陷

尝试每一种超参数组合，并根据交叉验证分数选择最佳组合，这使得 GridsearchCV 极其缓慢





# 随机搜索

使用随机搜索代替网格搜索的动机是，在许多情况下，所有的超参数可能并非同等重要。

随机搜索从超参数空间中随机选择参数组合，参数按 n_iter 给定的迭代次数进行选择。

随机搜索已经被实践证明比网格搜索得到的结果更好。

```python
from sklearn.model_selection import RandomizedSearchCV

knn = KNeighborsClassifier()

grid_param = { 'n_neighbors' : list(range(2,11)) , 
              'algorithm' : ['auto','ball_tree','kd_tree','brute'] }

rand_ser = RandomizedSearchCV(knn,grid_param,n_iter=10)
rand_ser.fit(X_train,y_train)

#best parameter combination
rand_ser.best_params_

#score achieved with best parameter combination
rand_ser.best_score_

#all combinations of hyperparameters
rand_ser.cv_results_['params']

#average scores of cross-validation
rand_ser.cv_results_['mean_test_score']
```



## 缺陷

随机搜索的问题是它不能保证给出最佳的参数组合。





# 贝叶斯优化

贝叶斯优化属于一类被称为sequential model-based optimization(SMBO)的优化算法

这些算法使用先前对损失 f 的观测，来确定下一个(最佳)点来取样 f

1. 使用先前计算过的点 X1: Xn，计算损失 f 的后验期望值。

2. 在一个新的点 Xnew取样损失 f ，它最大化了 f 的期望的某些效用函数。该函数指定 f 域的哪些区域是最适合采样的。

重复这些步骤，==直到达到某种收敛准则==。



贝叶斯优化算法通过对目标函数形状进行学习，找到使目标函数向全局最优值提升的参数。



具体来说，它学习目标函数形状的万法是：

- 首先根据先验分布，假设一个搜集函数
- 然后，每一次使用新的采样点来测试目标函数时，利用这个信息来更新目标函数的先验分布；
- 最后，算法测试由后验分布给出的全局最值最可能出现的位置的点。

```python
#pip install scikit-optimize
#另一个库：pip install bayesian-optimization
from skopt import BayesSearchCV

import warnings
warnings.filterwarnings("ignore")

# parameter ranges are specified by one of below
from skopt.space import Real, Categorical, Integer

knn = KNeighborsClassifier()
#defining hyper-parameter grid
grid_param = { 'n_neighbors' : list(range(2,11)) , 
              'algorithm' : ['auto','ball_tree','kd_tree','brute'] }

#initializing Bayesian Search
Bayes = BayesSearchCV(knn , grid_param , n_iter=30 , random_state=14)
Bayes.fit(X_train,y_train)

#best parameter combination
Bayes.best_params_

#score achieved with best parameter combination
Bayes.best_score_

#all combinations of hyperparameters
Bayes.cv_results_['params']

#average scores of cross-validation
Bayes.cv_results_['mean_test_score']
```





## 缺陷

对于贝叶斯优化算法，有一个需要注意的地方，一旦找到了一个局部最优值，它会在该区域不断采样，==所以很容易陷入局部最优值==。

为了弥补这个缺陷，贝叶斯优化算法会在探索和利用之间找到一个平衡点：

- 探索就是在==还未取样的区域==获取采样点
- 而利用则是根据后验分布在==最可能出现全局最值的区域==进行采样。



在2维或3维搜索空间中，需要十几个样本才能得到一个良好的替代曲面（surrogate surface）; 

增加搜索空间的维数需要更多的样本。



# 总结

在找到参数的最佳组合的保证和计算时间之间总是有一个权衡。

如果你的超参数空间(超参数个数)非常大，那么使用随机搜索==找到超参数的潜在组合==，然后使用该局部的网格搜索(超参数的潜在组合)来选择最优特征。



[作为一个一般性的经验法则，任何时候想要优化调整超参数，优先考虑网格化寻优方法和随机寻优方法！][id2]





# #参考文献

[link: 公众号我是算法工程师|4种主流超参数调优技术](https://my.oschina.net/u/4579551/blog/4675964)

[id2]: https://zhuanlan.zhihu.com/p/138005319 "link: deephub|机器学习模型的超参数优化"

- 超参数优化方法：上述4种调参方法
- 基于梯度的优化方法（Gradient-based Optimization）
- 进化寻优（Evolutionary Optimization）

