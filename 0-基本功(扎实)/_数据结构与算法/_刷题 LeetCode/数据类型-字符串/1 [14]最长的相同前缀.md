



## Q：







## Example:

```
Input: strs = ["flower","flow","flight"]
Output: "fl"


Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
```





## 特殊的限制条件

- `0 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` consists of only lower-case English letters.



# me 

- 123/123 cases passed (32 ms)
- Your runtime beats 20.61 % of python submissions
- Your memory usage beats 12.63 % of python submissions (13.9 MB)

```python
class Solution(object):
    def longestCommonPrefix(self, strs):
        """
        :type strs: List[str]
        :rtype: str
        """
        # 思路：两两比较，返回相同的字符串，用reduce函数
        # 边界情况：单词个数=0
        if len(strs) == 0:
            return ""
        # 边界情况：单词个数=1
        elif len(strs) == 1:
            return strs[0]

        return reduce(self.fn, strs)
    
    def fn(self, str_1, str_2):
        common_str = ""
        i = 0

        len_str_1 = len(str_1)
        len_str_2 = len(str_2)
        len_min = min(len_str_1, len_str_2)
        
        while i < len_min and str_1[i] == str_2[i]:   #先判断i < len_min
            common_str += str_1[i]
            i += 1
        return common_str
```



# 参考答案

zip函数对任意可迭代对象都适用

```python
strs = ["flower","flow","flight"]
l = list(zip(*strs))
>>> l = [('f', 'f', 'f'), ('l', 'l', 'l'), ('o', 'o', 'i'), ('w', 'w', 'g')]


# *strs的作用：
 i      0  1  2  3  4  5
 0      f  l  o  w  e  r
 1	    f  l  o  w
 2	    f  l  i  g  h  t


# zip组成元组
# list转换为列表
```



- 123/123 cases passed (20 ms)
- Your runtime beats 81.03 % of python submissions
- Your memory usage beats 68.22 % of python submissions (13.6 MB)

这么好的方法，结果没超90%

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        l = list(zip(*strs))
        prefix = ""
        for i in l:
            if len(set(i))==1:	#再用集合set判断是否是相同元素
                prefix += i[0]
            else:
                break
        return prefix
```





# #总结|关键点

1 注意边界情况：列表内的单词数量为1，或者为0时

2 list(zip(*strs))

- *(iters)：将可迭代对象拆解为迭代元素(容器/列表内有多少个对象，就生成多少个元素)
- zip()：将元素一一组合成元组(按照数量最少原则来匹配)
- list()：将这个包含元祖的元组转化为列表

3 set判断列表中的元素是否相同