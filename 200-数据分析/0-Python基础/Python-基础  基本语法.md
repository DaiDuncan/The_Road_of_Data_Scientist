# Python-基础 | 基本语法

## 一 操作内存

x = 1：对x进行赋值，变量存储在内存中





## 二 变量 操作符 常数 函数

```
x = 2   #赋值语句
x = x + 2   #赋值表达式
print(x)

'''
x：变量Variable
= +：操作符Operator
2：常量Constant
print()：函数Function
'''
```



## 三 基本语句

- 缩进

- - IDE/编辑器设置Tab键对应的空格数
  - 对于VIM

- - - set tabstop=4  "设置Tab显示的宽度为4个空格
    - set expandtab  "设置将Tab自动展开成为空格

python没有像matlab end那样明显的结束标记

- - 用 tab 缩进是可以的，但是要保证每行用同样个数的 tab
  - 用空格缩进是可以的，但是要保证每行用同样个数的空格 

- 看一下 **ASCII 码**，就知道空格和 tab 混用了
- Python中缩进可以用空格，也可以用tab，甚至可以混用

不管你怎么缩进的，你都要保证，第二行和第一行用的字符一样，第三行和第二行用的字符一样，…… ，也就是每一行用的字符一样。

其实 Python 并没有强制要求你用Tab缩进或者用空格缩进，但在 PEP8中，建议使用4个空格来缩进。

不仅仅是python，对于任何编程语言来说用space替代tab都是一个好的选择。

因为代码文件可能会在不同的环境、用不同的编辑器打开。对于space的处理，几乎所有的编辑器、OS都是一样的。而对于tab的处理却不尽相同，有的会直接展开成空格，有的不会，就算展开为空格，有的是4个，有的是8个……



### 1 顺序

一般语句不需加标点

### 2 条件

```
if exp:

elif exp:
...

else:
    
    
    
## try-except
```

- 注意冒号

#### 1）逻辑运算符号

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1136179/1592906699991-c6dcd090-154b-44da-8420-c493307cd085.png)

### 3 循环

- 注意冒号
- 缩进表示“程序框”

```
## 顺序
x = 2
print(x)
x = x + 2
print(x)


## 条件
x = 5
if x < 10:
    print('Smaller')
if x > 20:
    print('Bigger')

print('Finish')


## 循环
n = 5
while n > 0:
    print(n)
    n = n - 1
print('Blastoff!')
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1136179/1592902321080-bf463940-e18b-425e-9264-20ae657e5b59.png)

## 四 函数

### 1 调用函数的过程

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1136179/1592907677170-ee75d9dc-93e3-4ea9-a440-c53996befa4b.png)

### 2 函数的组成

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1136179/1592907727026-293e32b5-9891-4dd7-a31a-83029585e94d.png)

#### 2.1）函数的定义

```
def 函数名(参数):
    ...
    函数体
    ...
    返回值        #如果函数执行完毕也没有return语句时，自动return None。

    
## 空函数
def nop():
    pass()         #pass语句什么都不做，用来作为占位符。
```

#### 2.2）参数检查

调用函数时，如果参数个数不对，Python解释器会**自动检查**出来，并抛出TypeError；

如果参数类型不对，Python**解释器无法检查**，可通过内置函数isinstance()来实现。

```
li = []
ret = isinstance(li,list)
print(ret)    #True
```

#### 2.3）返回值

在python中根据返回对象的个数不同，返回结果的数据类型也不同

| 返回对象的个数 | 返回类型                 |
| -------------- | ------------------------ |
| 0              | NoneType                 |
| 1              | 取决于返回对象的数据类型 |
| >1             | tuple                    |

```
def f1():
    return

def f2():
    return True

def f3():
    return 1,2,3

print(type(f1()))   #<class 'NoneType'>
print(type(f2()))   #<class 'bool'>
print(type(f3()))   #<class 'tuple'>
```



### 3 函数的参数

#### 3.1）普通参数

#### 3.2）指定形参传入实参

#### 3.3）默认参数

默认参数可以简化函数的调用，但是需要放在参数列表最后，并且必须指向不变对象。

```
## 3.1）普通参数
# ######### 定义函数 ######### 
# name 叫做函数func的形式参数，简称：形参
def func(name):
    print(name)

# ######### 执行函数 ######### 
# 'morra' 叫做函数func的实际参数，简称：实参
func('morra')

=============================================
## 3.2）指定形参传入实参
def func(p, text, subject):
    ret = p + text + subject
    return ret

print(func(subject="XXX", p="123", text="OK"))    #使用该方法后不需要按顺序传入实参

=============================================
## 3.3）默认参数
def func(name, age = 18):        #
    print("%s:%s" %(name,age))

func('morra', 19)    # 指定参数
func('hello')        # 使用默认参数
```

#### 3.4）动态参数一（可变参数）

#### 3.5）动态参数二（关键字参数）

#### 3.6）动态参数三（万能参数）

```
## 3.4）动态参数一（可变参数）
def func(*args):        #在形参前加*之后args变成动态参数，该参数的数据类型变成了tuple元组
    print(type(args))    #<class 'tuple'>
    print(args)    

# 执行方式一
func(11, 33, 4, 4454, 5)    #可传入数字、字符串、列表、元组等等

# 执行方式二
# 这里需要注意一下，如果写func(*li) ，则表示把list转换为tuple再传入实参；\
# 如果写的是func(li)那么就表示把list当做tuple的元素(),传入实参。
li = [11,2,2,3,3,4,54]    
func(*li)       

=============================================
## 3.5）动态参数二（关键字参数）
def func(**args):        #在形参前加**之后，该参数的数据类型变成了dict字典
    print(type(args))    #<class 'dict'>print args
    print(args)   

# 执行方式一
func(name＝'morra',age=18)

# 执行方式二
li = {'name':'morra', age:18, 'gender':'male'}
func(**li)           

=============================================
## 3.6）动态参数三（万能参数）
def func(*args, **kwargs):
    print args
    print kwargs
```

#### 3.7）命名关键字参数

用来限制传入关键字参数的名字

- 命名关键字参数**必须传入参数名**，否则会报错：*分隔符之后的参数必须带参数名

```
def person(name, age, *, city, job):    #*不是参数，而是特殊分隔符       
    print(name, age, city, job)

person('morra', 18, city='beijing', job='engineer')

OUTPUT：
morra 18 beijing engineer

# 命名关键字参数必须传入参数名，否则会报错：
def person(name, age, *, city, job):
    print(name, age, city, job)

person('morra', 18, 'beijing', 'engineer')

OUTPUT：
Traceback (most recent call last):
  File "C:/test.py", line 6, in <module>
    person('morra', 18, 'beijing', 'engineer')
TypeError: person() takes 2 positional arguments but 4 were given
```





#### *参数**定义的顺序**

必选参数 > 默认参数 > 可变参数/命名关键字参数 > 关键字参数





## 五 特殊表达式

### 1 三目运算

学习条件运算时，对于**简单的 if else 语句**，可以使用三元运算来表示，即：

```
# ###################### 普通条件语句 ######################
if 1==1 :
    name = "hello"
else:
    name = "world"
# ###################### 三目运算 ######################
name = "hello" if 1==1 else "world"     
print(name)
```

### 2 lambda表达式

对于**简单的函数**，也存在一种简便的表示方式，即：lambda表达式

```
# ###################### 普通函数 ######################
# 定义函数（普通方式）
def func(arg):
    return arg + 1
    
# 执行函数
result = func(123)
    
# ###################### lambda ######################
# 定义函数（lambda表达式）
my_lambda = lambda arg : arg + 1
    
# 执行函数
result = my_lambda(123)
```





## 六 递归

py标准的解释器**没有针对递归做优化**，因此任何递归函数都存在栈溢出的问题。



```
# 利用递归函数计算阶乘
# N! = 1 * 2 * 3 * ... * N
def fact(n):
    if n == 1:
        return 1
    return n * fact(n-1)

print('fact(1) =', fact(1))
print('fact(5) =', fact(5))
print('fact(10) =', fact(10))


# 利用递归函数移动汉诺塔:
def move(n, a, b, c):
    if n == 1:
        print('move', a, '-->', c)
        return
    move(n-1, a, c, b)        
    print('move', a, '-->', c)
    move(n-1, b, a, c)

move(4, 'A', 'B', 'C')


# 斐波那契数列
def func(a, b):
    if a == 0:
        print(a, b)
    c = a + b
    print(c)
    func(b, c)

func(0, 1)
```



## 拓展

### 1 Coursera创建人

我们相信：教育是一个伟大的，让每个人变得平等的东西。

这个项目从4年前开始，当时我们一群受到嘉奖的教职员工，受到斯坦福 (Stanford)大学当时的本科教育副教务长John Bravman的邀请，去讨论怎么样才能，为课程提供更多的空间，使学生和教职员在其中能有富有意义的互动。

当时我们好几个人在房间里，互相交换自己的想法，当时并没有什么具体的东西成形。

两个月后，我恰好参加了一个谷歌部门会议，听他们关于YouTube的讲话，然后我突然就想到，与其在教室里面一遍遍地讲同样的，我已经讲了15年的课，在相同的时间，讲同样的笑话，或者我们可以把课程录下来，然后保存它，再让学生通过一种比在教室里教学更富互动性的方式，来获取与学习这些课程。

所以我又找到了John Bravman，他**当时就非常感兴趣**，把我带去见斯坦福教务长John Hennessey，他一直**对这个项目很有热情**，并为之提供帮助，包括用以组建技术的可观的种子补助资金，以及促进这个项目进行的教育培训。我们首先在我的课堂上尝试，然后新的点子在这个过程中产生，这些点子最终出现在Coursera平台上，包括短视频、学习评估与流视频的结合以及数量庞大的自动评分的学习评估，这些学习评估让学生可以测试他们关于这些学习材料的知识，这些是这个项目的一部分。

 

在2011年的秋天达到至高点，斯坦福大学有三个大型课程在那时向世界开放：**机器学习课程，数据库课程以及人工智能课程**，这三门课中的每一门都有100,000或者更多的学生参与，那真的是一种令人兴奋的体验。

 

这些学生自己在论坛里就建立起了学习小组。



### 2 Arduino创建人(意大利)

你做产品设计的时候，要记住这么一个原则：就是你要能够建立原型。

因为某种意义上来说，这个原则中的一个很重要的元素，就是能够**测试****与人交互****的方面的东西**。

 

微控制器很不喜欢Java，他们更喜欢像 C++ 或 C 这样的语言。

- 开源：发挥群众的力量

我们想 那干脆把硬件开源，这样大家想制作就制作。一旦他们开始制造，我们只要把 PCB (印刷电路板) 做成两孔的版本，然后把这个版本送给制作方，拿好这个 PCB组装一个出来。

然后就会有人开始组装，他们就会到网站上去，拿到说明开始写、下载代码，焊接电路板。

 

不同**社区的人**开始提到：有这么个叫Arduino的项目，前景不错。

我们多了120个忠实用户，用户会做出很精致的项目，设计出这些产品特性的人，会好好维护他们的项目，并在网上写好对应的文档，因为这是他们的作品集。

Arduino的概念是这样的。

很显然，现在我们周围的世界，就是由电子技术堆砌而成。

 

我觉得很重要的一点，尤其是对小孩子来说，去了解我们所存在于的这个世界。你抬头看这个房间，这个大楼，都**由人类设计、由人类建造**每一砖一瓦都是人类设计、建造的。很明显，如果你知道怎么**设计建造东西，**你就能影响你身边的世界。

如果你不能参与到电子世界的创造中，你就跟不上世界的脚步了，其他人就会进而参与设计你的世界。

 

某种意义上来说重要的是：我们应当成为科技的掌控者。



### 3 Python创始人 Guido van Rossum(荷兰 哈勒姆)

那时我在CWI (阿姆斯特丹国家数学和计算机科学研究所) 为一个项目工作Amoeba 分布式操作系统那个项目。

 

在Python社区，吉多·范罗苏姆被人们认为是终身仁慈独裁者，意思是他仍然关注Python的开发进程，并在必要的时刻做出决定。**2018年7月12日**，他宣布不再担任Python社区的BDFL。

 

- 问题背景——想创建一种自带的软件

其中一个子项目是给 Amoeba 系统的一些系统软件，给 Amoeba 系统，那个操作系统网络交互性很好，它的应用进程管理也不错，但**没什么用户层面的软件。**

就只有一个 shell (命令行)，我感觉是一个移植的非常老旧的，像 Unix 第6代命令行那样的软件。

由于 Amoeba 系统上的文件系统模块和 Unix 非常不同，我们无法直接使用现有的 Unix 程序。

 

如果要这样做的话，我们需要大量用户层面的东西：譬如应用软件、应用工具等等。

从一个编辑器到一个邮箱程序到一个登陆实用程序和备份工具，然后我意识到我们这么小的一个团队，要做这些事情，**用C语言开发是特别花时间**的。

 

然后做这些事情也**并不是特别有趣或新颖**，而且**也并不是也别困难。** 

况且，我们也并不在意这些程序是不是运行得非常快，所以我们要用C来开发这些程序的理由，实际上并不成立。

 

- 启发-ABC

当时我感觉 ABC 语言更适合，用来给 Amoeba 开发这一整套系统软件。

除了 ABC 太高级太抽象可能不太好用，这也导致它并不擅长和服务器、文件系统以及和进程进行会话，整个操作系统使 ABC 抽象化。

 

它可以使用用户数据做所有聪明的操作，并且它做这些事情是通过使用像list(列表)和dictionary(词典)这样通用的数据结构。

此外它的代码结构也很棒，就像一些非常简单的声明，而且你也可以通过一些简单的组合创造新的结构。

还有那些常见的函数和流程抽象，它并不完全是一个面向对象的语言，虽然一些实现有类似对象这样的东西。不管怎样，因为我曾经参与 ABC语言的开发，虽然它当时不太可用，但是我还是知道这个语言是怎么构造出的。

我当时就有这样一个想法，如果我有做我们当时项目这么多时间，我可以开发出一套全新的语言，从草稿开始设计并实现它。因为我知道 ABC 的设计和实现方法，然后用这个新语言开发我们需要的工具，然后我们还是要比纯粹使用C语言开发进度快。

 

在接下来连续的三个月里，我白天做项目的工作，晚上一有时间我就忙着开发 Python。

我当时就相信，不到三个月时间，我就能告诉大家：看！这就是我做的 Python。

 

另外，我并不知道这些事情发生多快，但我确实有两个办公室同事，立即开始着手帮助。

然后还有**几个机构里的其他同事**，对我做的这个东西非常感兴趣，然后开始。

 

因为在1990年底的时候，也就是我开始做这个新语言一年以后，我们计划着做这个新语言 (Python) 的开源发行。

 

- 请教专业人士

于是我去问我经理的经理，我们应该怎么发行？他说你应该和 我们所这个部门的这个人谈一谈，然后我就和那个女人聊了下，她好像是**负责法律事务**的。

我说我写了这个源代码并且我想把它发布出去，当时我已经做了一个类似 MIT许可证的许可。MIT就是按照这个许可来发布软件的，我们也可以类似地把我们机构的名字放在这里，就是我们机构正式的名字而不是机构评议员的名字。她问了一些诸如有没有人资助我开发它的问题，然后我说没有，这都是我在自己的时间做的。

 

我感觉这是一个难以置信的里程碑，我们需要把它发布在 Usenet (一种**分布式互联网交流系统**)上。

当时有一个 Usenet 新闻组。

就这些林林总总的事情，90年代上半期发生的最大的事情就是 Python 用户和开发者自发组成了社区。

后来美国那边邀请我去 NIST 工作几个月。

 

就是美国国家标准与技术研究院，我就在那里花了两个月。

组织了第一个 Python 研讨会，在那个 Python 研讨会上，我遇到了一些想雇佣我的人。

**我回荷兰待了几个月，**然后从1995年到2000年，我就在美国弗吉尼亚的 CNRI 工作。



- 不断更新迭代

1.5.0版本什么都不是，但是1.5.2版本保存了一些 标准，很长一段时间成为了Python的黄金标准。



我在不是很满意的地方工作了五年

我们真正启动的时候是2000年，而刚好在我们的启动日期是5月15日。那时泡沫已经破灭了，我甚至没有意识到那里存在一个泡沫，而且这个泡沫已经破灭。

当时我在北弗吉尼亚州做开放源码软件，我真的不知道是怎么启动的，我不知道怎么去辨别这些人是否值得信赖。

 

在软件律师方面，我们商量了一些办法，以确保Python保持开源，拥有CNRI律师许可的执照。

然而在五个月内，这一切结束了，他们突然停止了对我们的资助，这个初创公司开始暴露越来越多反常的征兆。

我们在这个洞里越陷越深，在那一年快结束时，投资者停止了融资，然后我们就像突然无家可归了。

我们情况还相对乐观，因为我们在这之前一直都有可观的薪水。

 

但是，我们当时正在与温哥华的一家小型软件公司，以及Zope公司——北弗吉尼亚州的一家小型Python独家软件公司，最后整个Python实验团队。

我们五个人决定为Zope工作，这是一次对我们非常幸运的救援。Zope它很明确，他们说：我们没有设计这个软件的所有权。我们需要你们，你们是非常出色的程序员，你们在Python社区里是最出色的。

 

我们只是做开源开发，没有人可以坚持，结果我们成长得非常快。我们继续做了很多 Python的重要基本工作，同时我们也做了很多Zope的重要工作，慢慢地，团队解散了。

 

我得到了加州一家初创公司的邀请，这次我更好地做了功课：Python持续在成长，而社区也持续在自我组织。

一开始在1994年我们有大概20到25人，参与了研讨会。在几年时间内，我们曾经举办了一次年度的会议，我们称其为国际 Python 会议，有三四百人参与。

我一直鼓励社区自我组织：而不是靠我做每个决定。



## 参考文献

[cnblogs | python函数基础](https://www.cnblogs.com/whatisfantasy/p/5967283.html)