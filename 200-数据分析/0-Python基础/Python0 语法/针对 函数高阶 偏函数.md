装饰器改变了一个函数的行为，而偏函数不能改变一个函数的行为。偏函数只能根据已有的函数生成一个新的函数，这个新的函数完成已有函数相同的功能，但是，这个新的函数的==部分参数已被偏函数确定下来==



# 回顾|函数参数

通过设定参数的默认值，可以降低函数调用的难度 => 偏函数也可以做到这一点





# 示例|int()

int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换

但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：

```python
>>> int('12345', base=8)
5349
>>> int('12345', 16)
74565
```

假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去

```python
def int2(x, base=2):
    return int(x, base)
```





# functools.partial

帮助我们创建一个偏函数

```python
>>> import functools
>>> int2 = functools.partial(int, base=2)
>>> int2('1000000')
64
>>> int2('1010101')
85
```

简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单

这个新的函数在调用时也可以传入其他值：

```python
>>> int2('1000000', base=10)
1000000
```





## 可选参数

创建偏函数时，实际上可以接收函数对象、`*args`和`**kw`这3个参数

```python
int2 = functools.partial(int, base=2)
'''int2('10010')相当于：
kw = { 'base': 2 }
int('10010', **kw)
'''


max2 = functools.partial(max, 10)
'''把10作为*args的一部分自动加到左边
比如：max2(5, 6, 7) 
等价于：
args = (10, 5, 6, 7)
max(*args)
'''

```





## 示例@STL functool-偏函数



# #小结

当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数

这个新函数**可以固定住原函数的部分参数**，从而在调用时更简单。







