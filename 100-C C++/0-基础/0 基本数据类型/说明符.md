有些被称为存储说明符（storage class specifier）或cv-限定符（cv-qualifier）的C++关键字提供了一些有关存储的信息。



## 存储说明符：

* auto (在C++11中不再是说明符);
* register;
* static;
* extern;
* thread_local（C++11新增的）;
* mutable

在同一个声明中不能使用多个说明符，但thread_local除外，它可与static或extern结合使用



在C++11之前，可以在声明中使用关键字auto指出变量为自动变量；但在C++11中，auto用于自动类型推断

在C++11之前，register用于在声明中指示寄存器存储，而在C++11中，它指示显式地指出变量是自动的



关键字static：

- 被用在作用于为整个文件的声明中时，表示内部链接性；

- 被用于局部声明中，表示局部变量的存储持续性为静态的。



关键字extern表明是引用声明，即声明引用在其他地方定义的变量。



关键字thread_local指出变量的持续性与其所属线程的持续性相同。

- thread_local变量之于线程，犹如常规静态变量之于整个程序。





mutable。可以用它来指出，即使==结构（或类）变量==为const，其某个成员也可以被修改

```c++
struct data
{
    char name[30];
    mutable int accesses;
    ...
};
const data veep = {"Alaybourne Clodde", 0, ... };
strcpy(veep.name, "moonlit");   // not allowed
veep.accesses ++;               // allowed
```

veep的const限定符禁止程序修改veep的成员，但access成员的mutable说明符使得access不受这种限制。





## cv-限定符

cv是const和volatile的首字母缩写

* const
* volatile



关键字const表明，内存被初始化后，程序便不能再对它进行修改。

在C++（但不是C语言）中，const限定符对默认存储类型稍有影响。

在默认情况下全局变量的链接型为外部的，但const全局变量的链接型为内部的。

也就是说，在C++看来，全局const（如下述代码段所示）就像使用了static说明符一样。

```c++
const int fingers = 10; // same as static const int fingers = 10;
int main(void)
{   
    ...
```

例如，假设将一组常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那么，预处理其将头文件的内容包含到每个源文件中后，所有的源文件都将包含类似下面这样的定义：`const int fingers = 10;`

如果全局const声明的链接像常规变量那样是外部的，则根据单定义规则，这将出错。也就是说，==只能有一个文件可以包含前面的声明，而其他文件必须使用extern关键字来提供引用声明==。

另外，只有未使用extern关键字的声明才能进行初始化。

因此，需要为某个文件使用一组定义，而其他文件使用另一组声明。

如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性



请记住，鉴于单个const在多个文件之间共享，因此只有一个文件可对其进行初始化。

在函数或代码块中声明const时，其作用域为代码块，即仅当程序执行代代码块中的代码时，该常量才是可用的。这意味着在函数或代码块中创建常量时，不必担心其名称与其他地方定义的常量发生冲突。







关键字volatile表明，即使程序代码**没有对内存单元进行修改，其值也可能发生变化**。

例如，可以将指针指向某个硬件位置，其中包含了来自串行端口的时间和信息。

在这种情况下，硬件（而不是程序）可能修改其中的内容。或者两个程序可能互相影响，共享数据。

该关键字的作用是为了改善编译器的优化能力。

例如，假设编译器发现，程序在几条语句中连续使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是**将这个值缓存到寄存器中**。

这种优化假设变量的值在着来那个词使用之间不会变化。

- 如果不将变量声明为volatile，则编译器将进行这种优化。

- 将变量声明为volatile，相当于告诉编译器，不要进行这种优化。





# #补充说明

有人会说，了解内存使用情况不在程序员的工作范围之内，但他们是错的。

对于C ++程序员而言，了解“幕后”发生的事情对于成为高级程序员至关重要。



