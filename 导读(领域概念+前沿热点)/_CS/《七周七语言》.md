# 内容介绍 2012-5-8

从计算机发展史早期的Cobol、Fortran到后来的C、Java，编程语言的家族不断壮大。除了这些广为人知的语言外，还涌现了Erlang、Ruby等后起之秀，它们虽被喻为==小众语言==，但因其独特性也吸引了为数不少的追随者。

Bruce A. Tate是软件行业的一名老兵，他有一个宏伟目标：用一本书的篇幅切中要害地探索七种不同的语言。本书就是他的成果。

书中介绍了Ruby、Io、Prolog、Scala、Erlang、Clojure和Haskell这七种语言，关注每一门语言的精髓和特性，重点解决如下问题：

- 这门语言的类型模型是什么
- ==编程范式==是什么
- 如何与其交互
- 有哪些==决策构造和核心数据结构==
- 有哪些独特的核心特性

在这个飞速发展的信息时代，程序员仅仅掌握甚至精通一门语言是远远不够的。==了解多门语言蕴涵的思维方式，在编码中互相借鉴==，再挑出一两门对自己口味的语言深入学习，

这些已经成为在软件行业中安身立命之本。从这个意义上说，每个程序员都应该看看这本《七周七语言》



## 作者

Bruce A. Tate RapidRed公司总裁，该公司主要为Ruby轻量级开发提供咨询。他曾任职于IBM公司，并担任过多家公司的客户解决方案总监和CTO。著作有十余本，包括荣获Jolt大奖的Better, Faster, Lighter Java。



译者简介：

戴玮 80后宅男，中科院自动化所在读博士，热爱机器学习与计算机视觉。编程喜C#、Ruby、Haskell而厌Java。

白明 Neusoft某开发部技术总监，拥有多年==电信级软件==开发经验；资深C程序员，对Common Lisp、Python等小众语言也有涉猎；对开源软件有着浓厚的兴趣，曾先后贡献了lcut、cbehave等多个工具框架；喜好写博客http://bigwhite.blogbus.com），耕耘七年，仍孜孜不倦。

巨成 万方数据数字出版事业部架构师，.NET开发人员。



## 目录



第1章 简介 1

1.1 不走寻常路 1

1.2 语言 2

1.3 谁应该买这本书 4

1.3.1 学会如何学习 4

1.3.2 乱世英雄 4

1.4 谁不应该买这本书 5

1.4.1 超越语法 5

1.4.2 不是安装指南 6

1.4.3 不是编程参考 6

1.4.4 严格督促 6

1.5 最后一击 7



第2章 Ruby 8

2.1 Ruby简史 9

2.2 第一天：找个保姆 10

2.2.1 快速起步 10

2.2.2 从命令行执行Ruby 10

==2.2.3 Ruby的编程模型== 11

2.2.4 判断 12

2.2.5 鸭子类型 15

2.2.6 第一天我们学到了什么 16

2.2.7 第一天自习 16

2.3 第二天：从天而降 17

2.3.1 定义函数 17

2.3.2 数组 17

2.3.3 散列表 19

2.3.4 代码块和yield 20

2.3.5 定义类 22

2.3.6 编写Mixin 25

2.3.7 模块、可枚举和集合 26

2.3.8 第二天我们学到了什么 27

2.3.9 第二天自习 28

2.4 第三天：重大改变 28

2.4.1 打开类 29

2.4.2 使用method_missing 30

2.4.3 模块 31

2.4.4 第三天我们学到了什么 35

2.4.5 第三天自习 35

2.5 趁热打铁 35

2.5.1 核心优势 35

2.5.2 不足之处 37

2.5.3 最后思考 37



第3章 Io 38

3.1 Io简介 38

3.2 第一天：逃学吧，轻松一下 39

3.2.1 开场白 39

3.2.2 对象、原型和继承 40

3.2.3 方法 43

3.2.4 列表和映射 44

3.2.5 true、false、nil以及单例 46

3.2.6 Steve Dekorte访谈录 48

3.2.7 第一天我们学到了什么 49

3.2.8 第一天自习 50

3.3 第二天：香肠大王 50

3.3.1 条件和循环 51

3.3.2 运算符 52

3.3.3 消息 54

3.3.4 反射 56

3.3.5 第二天我们学到了什么 57

3.3.6 第二天自习 57

3.4 第三天：花车游行和各种奇妙经历 58

3.4.1 领域特定语言 58

3.4.2 Io的method_missing 60

3.4.3 并发 62

3.4.4 第三天我们学到了什么 64

3.4.5 第三天自习 64

3.5 趁热打铁 65

3.5.1 核心优势 65

3.5.2 不足之处 66

3.5.3 最后思考 66



第4章 Prolog 67

4.1 关于Prolog 68

4.2 第一天：一名优秀的司机 68

4.2.1 基本概况 68

4.2.2 基本推论和变量 69

4.2.3 填空 70

4.2.4 合一，第一部分 73

4.2.5 实际应用中的Prolog 75

4.2.6 第一天我们学到了什么 77

4.2.7 第一天自习 77

4.3 第二天：离瓦普纳法官开演还有15分钟 78

4.3.1 递归 78

4.3.2 列表和元组 79

4.3.3 列表与数学运算 82

4.3.4 在两个方向上使用规则 83

4.3.5 第二天我们学到了什么 86

4.3.6 第二天自习 87

4.4 第三天：维加斯的爆发 87

4.4.1 解决数独问题 87

4.4.2 八皇后问题 91

4.4.3 第三天我们学到了什么 96

4.4.4 第三天自习 96

4.5 趁热打铁 96

4.5.1 核心优势 97

4.5.2 不足之处 97

4.5.3 最后思考 98



第5章 Scala 99

5.1 关于Scala 99

5.1.1 与Java的密切关系 100

5.1.2 没有盲目崇拜 100

5.1.3 Martin Odersky访谈录 100

5.1.4 函数式编程与并发 101

5.2 第一天：山丘上的城堡 102

5.2.1 Scala 类型 102

5.2.2 表达式与条件 103

5.2.3 循环 105

5.2.4 范围与元组 107

5.2.5 Scala中的类 109

5.2.6 扩展类 111

5.2.7 第一天我们学到了什么 113

5.2.8 第一天自习 114

5.3 第二天：修剪灌木丛和其他新把戏 114

5.3.1 对比var和val 115

5.3.2 集合 115

5.3.3 集合与函数 119

5.3.4 第二天我们都学到了什么 124

5.3.5 第二天自习 124

5.4 第三天：剪断绒毛 125

5.4.1 XML 125

5.4.2 模式匹配 126

5.4.3 并发 128

5.4.4 实际中的并发 129

5.4.5 第三天我们学到了什么 132

5.4.6 第三天自习 132

5.5 趁热打铁 133

5.5.1 核心优势 133

5.5.2 不足之处 134

5.5.3 最后思考 135



第6章 Erlang 136

6.1 Erlang简介 136

==6.1.1 为并发量身打造== 137

6.1.2 Joe Armstrong博士访谈录 138

6.2 第一天：以常人面目出现 139

6.2.1 新手上路 140

6.2.2 注释、变量和表达式 140

6.2.3 原子、列表和元组 141

6.2.4 模式匹配 142

6.2.5 函数 144

6.2.6 第一天我们学到了什么 147

6.2.7 第一天自习 147

6.3 第二天：改变结构 148

6.3.1 控制结构 148

6.3.2 匿名函数 150

6.3.3 列表和高阶函数 150

6.3.4 列表的一些高级概念 153

6.3.5 第二天我们学到了什么 156

6.3.6 第二天自习 157

6.4 第三天： 红药丸 157

6.4.1 基本并发原语 157

6.4.2 同步消息 160

6.4.3 链接进程以获得可靠性 162

6.4.4 第三天我们学到了什么 167

6.4.5 第三天自习 167

6.5 趁热打铁 167

6.5.1 核心优势 168

6.5.2 不足之处 169

6.5.3 最后思考 169



第7章 Clojure 170

7.1 Clojure入门 170

7.1.1 一切皆Lisp 170

7.1.2 JVM 171

7.1.3 为并发更新 171

7.2 第一天：训练Luke 172

7.2.1 调用基本函数 172

7.2.2 字符串和字符 174

7.2.3 布尔值和表达式 175

7.2.4 列表、映射表、集合以及向量 176

7.2.5 定义函数 179

7.2.6 绑定 180

7.2.7 匿名函数 182

7.2.8 Rich Hickey访谈录 183

7.2.9 第一天我们学到了什么 184

7.2.10 第一天自习 185

7.3 第二天：Yoda与原力 185

7.3.1 用loop和recur递归 185

7.3.2 序列 186

7.3.3 延迟计算 189

7.3.4 defrecord和protocol 191

7.3.5 宏 193

7.3.6 第二天我们学到了什么 194

7.3.7 第二天自习 195

7.4 第三天：一瞥魔鬼 195

7.4.1 引用和事务内存 196

7.4.2 使用原子 197

7.4.3 使用代理 198

7.4.4 future 200

7.4.5 还差什么 200

7.4.6 第三天我们学到了什么 201

7.4.7 第三天自习 201

7.5 趁热打铁 201

7.5.1 Lisp悖论 202

7.5.2 核心优势 202

7.5.3 不足之处 203

7.5.4 最后思考 204



第8章 Haskell 205

8.1 Haskell简介 205

8.2 第一天：逻辑 206

8.2.1 表达式和基本类型 206

8.2.2 函数 208

8.2.3 元组和列表 211

8.2.4 生成列表 214

8.2.5 Philip Wadler访谈录 217

8.2.6 第一天我们学到了什么 218

8.2.7 第一天自习 218

8.3 第二天：Spock的超凡力量 218

8.3.1 高阶函数 219

8.3.2 偏应用函数和柯里化 220

8.3.3 惰性求值 221

8.3.4 Simon Peyton-Jones访谈录 223

8.3.5 第二天我们学到了什么 224

8.3.6 第二天自习 225

8.4 第三天：心灵融合 226

8.4.1 类与类型 226

8.4.2 monad 231

8.4.3 第三天我们学到了什么 236

8.4.4 第三天自习 237

8.5 趁热打铁 237

8.5.1 核心优势 237

8.5.2 不足之处 238

8.5.3 最后思考 239



==第9章 落幕时分 240==

9.1 编程模型 240

9.1.1 面向对象（Ruby、Scala） 241

❓9.1.2 原型编程（Io） 241

❓9.1.3 约束-逻辑编程（Prolog） 241

9.1.4 函数式编程（Scala、Erlang、Clojure、Haskell） 241

❓9.1.5 范型演进之路 242

❓9.2 并发 242

❓9.2.1 控制可变状态 243

9.2.2 Io、Erlang和Scala中的actor 243

9.2.3 future 243

❓9.2.4 事务型内存 243

❓9.3 编程结构 244

9.3.1 列表解析 244

❓9.3.2 monad 244

9.3.3 匹配 245

9.3.4 合一 246

9.4 发现自己的旋律 246



附录 参考书目 247





# #参考文献

[Link：豆瓣|七周七语言](https://book.douban.com/subject/10555435/)