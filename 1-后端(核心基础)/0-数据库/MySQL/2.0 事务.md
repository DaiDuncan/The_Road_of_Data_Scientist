

事务是由一组SQL语句组成的逻辑处理单元，主要用于处理**操作量大，复杂度高的数据**。

例如：在人员管理系统中删除一个人员，需要删除人员的基本资料，也需要删除人员相关 的信息，这些数据库操作语句就过程一个事务。

# 事务的基本要素ACID

- 原子性（Atomicity）
  整个事务中的所有操作，要么全部完成，要么全部不完成，不能停滞在中间某个环节。**事务执行过程中发生错误，会被回滚到事务开始前的状态。**

- 一致性（Consistency）
  在事务开始之前和事务结束后，数据库的**完整性约束**没有被破坏。

- 隔离性（Isolation）
  一个事务的执行不会被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务是隔离的，**并发执行的各个事务之间不会互相干扰。**

- 持久性（Durability）
  在事务完成以后，该事务所对数据库所作的更改便**持久的保存在数据库**中，不会被回滚。



# 并发事务代来的问题

- 更新丢失（Lost Update）
  事务A和事务B**选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题。**

- 脏读（Dirty Reads）@Github同步思想
  事务A读取了事务B更新的数据，然后**事务B回滚操作，那么A读取到的数据是脏数据。**

- 不可重复读（Non-Repeatable Reads）
  事务A多次读取同一数据，事务B在事务A多次读取的过程中，**对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。**

- 幻读（Phantom Reads）
  幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着**另一个并发事务B插入了一些数据**时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。





# 事务隔离级别

- Read-Uncommitted（读未提交）
  最低的隔离级别，**允许读取尚未提交的数据变更**，可能会导致脏读、幻读或不可重复读。

- Read-Committed（读已提交）
  允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

- Repeatable-read（可重复读）
  对同一个字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。==MySQL默认隔离级别==。

- Serializable（可串行化）
  最高的隔离级别，完全服从ACID的隔离级别。**所有的事务依次逐个执行**，这样事务之间就完全不可能产生干扰。该级别可以防止脏读、不可重复读、幻读。



查看当前数据库隔离级别

```mysql
#==# 旧版写法，MySQL 5.7.20后被弃用
show variables like 'tx_isolation';
# 或者：
select @@tx_isolation;


#==# 新版写法。
show variables like 'transaction_isolation';
# 或者 
select @@transaction_isolation;
```





# MVCC 多版本并发控制

MVCC是**行级锁**的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。

虽然实现机制有所不同，但大都**实现了非阻塞的读操作**，**写操作也只是锁定必要的行**。

MVCC的实现是通过保存**数据在某个时间的快照**来实现的。不管需要执行多长时间，每个事务看到的数据都是一致的。

- MVCC只在Committed Read 和 Repeatable Read 两种隔离级别下工作。



## MVCC实现原理

- InnoDB的MVCC，是通过在**每行记录后面保存两个隐藏的列来实现**。
  - 一列保存了行的创建时间，
  - 一列保存行的过期时间（或删除时间）。
  - 存储的并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行的版本号进行比较。



Repeatable Read 隔离级别下，MVCC工作方式

- select

  InnoDB会根据以下两个条件检查每行记录，只有符合这两个条件才会被查询出来。

  - InnoDB只查找**创建版本号小于或等于当前事务版本号的数据行**，这样可以确保事务读取的行，要么是在开始事务之前已经存在，要么是事务自身插入或修改过的。

  - 过期版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除。

- insert
  InnoDB为新插入的每一行保存当前系统版本号**作为行创建时间**。

- delete
  InnoDB为删除的每一行保存当前系统版本号**作为行过期时间**。

- update
  InnoDB为插入的一行新纪录保存当前系统版本号作为行创建时间，同时保存当前系统版本号到原来的行作为过期时间；





举例说明

1）初始工作

![img](https://raw.githubusercontent.com/DaiDuncan/PicUploader/main/img3/20210529114012.jpeg)



2）SELECT

![img](https://raw.githubusercontent.com/DaiDuncan/PicUploader/main/img3/20210529114157.jpeg)



3）UPDATE

![img](https://raw.githubusercontent.com/DaiDuncan/PicUploader/main/img3/20210529114230.jpeg)



4）DELETE

![img](https://raw.githubusercontent.com/DaiDuncan/PicUploader/main/img3/20210529114554.jpeg)



优点：

- 解决不可重复读和幻读的问题；
- ==大多数操作都不用加锁，使数据操作简单，性能好==。

缺点：

- 每行记录都需要额外的存储空间，**需要做更多的行检查工作和一些额外的维护工作**。







# 事务日志

InnoDB**使用日志来减少提交事务时的开销**。

因为日志中已经记录了事务，就无需在每个事物提交时把缓冲池的脏块刷新到磁盘中。

事务修改的数据和索引通常会映射到表空间的随机位置，**所以刷新这些变更到磁盘需要很多随机IO**。

随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。

InnoDB用日志把随机IO变成顺序IO。**一旦日志安全写到磁盘，事务就持久化了**，即使断电了，InnoDB重启后可以**通过redo log恢复以及提交的事务**。

InnoDB使用一个**后台线程**智能地刷新这些变更到数据文件。

这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。



## 事务的实现

- 事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。
  - MySQL 中**支持事务**的存储引擎有 InnoDB 和 NDB。

- 事务的实现就是实现ACID特性。
  - 事务隔离性是通过锁实现，而事务的原子性、一致性和持久性则通过事务日志实现。



事务日志包括：redo log（重做日志）和undo log（回滚日志）

- redo log（重做日志）实现持久化和原子性

  - 在InnoDB存储引擎中，事务日志通过redo log 和日志缓存（InnoDB Log Buffer）实现。

  - 事务开启时，事务中的操作，都会先写入存储引擎的日志缓存中，**在事务提交之前，这些缓存的日志都需要提前刷新到磁盘上持久化，这就是“日志先行”（Write-Ahead logging）**.

  - 当事务提交之后，在Buffer Pool中影射的数据文件才会慢慢刷新到磁盘。此时如果宕机，那么当系统重启进行恢复时，可以根据redo log中记录的日志，把数据库恢复到奔溃前的一个状态。**未完成的事务，可以继续提交或者选择回滚，这基于恢复的策略而定。**

  - 在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录redo log，通过顺序IO改善性能。**所有事务共享redo log的存储空间，它们的redo log按语句的执行顺序，一次交替的记录在一起。**

redo log 记录示例：

![img](https://raw.githubusercontent.com/DaiDuncan/PicUploader/main/img3/20210529120544.jpeg)



- undo log（回滚日志） 实现一致性

  - undo log主要为事务的回滚服务。

  - undo log记录了数据在**某个操作前的状态**，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。

  - undo log记录的是已部分完成并写入磁盘的未完成（未提交）的事务。

  - **单个事务的回滚，不会影响到其他事务做的操作**。



- redo log 与 undo log 的区别

  - 两种日志都是为了恢复操作。

  - redo log是恢复提交**事务修改的页操作**。而undo log是**回滚行记录到特定版本**。

  - 两者记录的内容也不同，redo log是物理日志，记录页的物理修改操作。而undo log是逻辑日志，根据每行记录继续记录。



- redo + undo log简化过程，假设操作示例

  ![img](https://raw.githubusercontent.com/DaiDuncan/PicUploader/main/img3/20210529121003.jpeg)

  -  在1-8的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响。
  - 如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为**此时redo log已经持久化**。
  - 若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘。



# Q&A

1 事务的隔离级别有哪些？MySQL默认隔离级别是什么？

2 MySQL事务的四大特性及实现原理？

3 MVCC是什么，它的底层原理是？

4 什么是幻读、脏读、不可重复读？

5 不可重复读与幻读的区别？

- 不可重复读的重点是修改
  在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）

- 幻读的重点在于新增或删除
  在同一事务中，同样的条件，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入或删除）



6 并发事务处理带来的问题及解决办法

- 更新丢失
  - 通常是应该完全避免的。
  - 但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此**防止更新丢失应该是应用的责任**。

- 脏读、不可重复读、幻读 都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决

  - 一种是加锁
    在**读取数据前，对其加锁，阻止其他事务对数据进行修改**。

  - 另一种是多版本并发控制
    不用加任何锁，通过一定机制生成一个数据请求时间点的**一致性数据快照**，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本。



7 MySQL有多少种日志？

- 错误日志
  记录出错信息，也记录一些警告信息或者正确的信息。

- 查询日志
  记录所有对数据库请求的信息，不论这些请求是否得到正确的执行。

- 慢查询日志
  设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。

- 二进制日志
  记录数据库执行更改的所有操作。

- 中继日志
  也是二进制日志，用来给slave库恢复。

- 事务日志⭐
  重做日志（redo log）和回滚日志（undo log）。

