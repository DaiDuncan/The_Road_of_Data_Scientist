存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。

一个数据库中多个表**可以使用不同引擎**以==满足各种性能和实际需求==。



# 查看存储引擎

- 查看支持的存储引擎
  SHOW ENGINES

- 查看**默认**存储引擎
  SHOW VARIABLES LIKE '%storage_engine%'

- 准确查看某个数据库中的**某一表所使用的存储引擎**
  show table status like 'tablename'



# 设置存储引擎

- **建表时指定存储引擎**（默认的就是INNODB，不需要设置）
  CREATE TABLE t1 (i INT) ENGINE = INNODB;

- 修改存储引擎
  ALTER TABLE t ENGINE = InnoDB;

- **修改默认存储引擎**，也可以在配置文件my.cnf中修改默认引擎
  SET default_storage_engine=NDBCLUSTER;



# 存储引擎对比

- InnoDB**支持事务**；MyISAM不支持事务；

- InnoDB**支持外键**；MyISAM不支持；对一个包含外键的InnoDB表转MyISAM会失败；

- InnoDB是**聚簇索引**；MyISAM是非聚簇索引；
  - 聚簇索引的文件存放在==主键索引的叶子节点==上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，**主键不应该过大(哈希表比较短小)，因为主键太大，其他索引也都会很大**。
  - 而 MyISAM 是非聚集索引，数据文件是分离的，**索引保存的是数据文件的指针**。主键索引和辅助索引是独立的。

- InnoDB不保存表的具体行数，执行 select count(*) from table 需要**全表扫描**；MyISAM**用一个变量保存了整个表的行数**，执行上述语句读出该变量即可，速度非常快；

- InnoDB最小的**锁粒度是行锁**，适合高并发；MyISAM最小的锁粒度是表锁，不适合高并发；一个更新语句会锁住整张表，**导致其他查询和更新都会被阻塞，因此并发访问受限**。

- InnoDB不仅缓存索引还**缓存真实数据**，对内存要求较高，内存大小对性能有决定性的影响；MyISAM只缓存索引，不缓存真实数据；

- InnoDB表占用空间大；MyISAM表占用空间小；

- InnoDB**关注点在事务**；MyISAM关注点在性能；



# Q&A

1 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？

- 如果**表的引擎**是MyISAM，那么是18。因为MyISAM表会把自增主键的**最大ID 记录到数据文件中**，重启MySQL自增主键的最大ID也不会丢失；

- 如果表的引擎是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID**记录到内存中**，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。



2 哪个存储引擎执行 select count(*) 更快，为什么？

- MyISAM更快，因为MyISAM内部维护了一个计数器，把表的总行数存储在磁盘上，可以直接调取；

- InnoDB没有将表的总行数存储在磁盘上，需要全表扫描累加行数，所以数据表越大越耗时；InnoDB这样做的苦衷与其**支持事务有关**，由于多版本并发控制（MVCC）的原因，InnoDB表“应该返回多少行”是不确定的。

