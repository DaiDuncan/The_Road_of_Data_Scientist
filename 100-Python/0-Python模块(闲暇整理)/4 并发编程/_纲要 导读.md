# 教程|酷python

现代计算机的CPU几乎都是多核的，有些还有多个处理器，为了利用这些额外的处理能力，操作系统定义了线程这个低级结构：

- 一个进程可以创建并拥有多个线程，这些线程可以共享这个进程的资源
- 就在你通过浏览器阅读本文时，你的浏览器已经开启了多个线程为你服务



与单个线程不同，多线程由于共享进程的资源，在修改内存中的变量时，必须考虑互斥问题

- python的C语言实现提供了GIL锁，这使得python与其他语言相比，==并不能提供真正意义上的多线程==，但在IO密集型编程任务中，python的多线程仍然有应用价值。





关于多线程，你需要了解：

- 为何多线程同时修改一个变量时需要互斥
- 以及多线程之间如何同步
- 一般的多线程编程不会涉及这些知识点

但如果你想完成进阶，成为高手，就必须在这些艰涩难懂的知识中挣扎，直到熟练掌握，深刻理解。





基于POSIX的线程（例如Mac OS和Linux）和Windows OS之间的线程结构和API是不同的，但python对此进行了封装，因此，你在使用时，感知不到这其中的差别。





鉴于GIL锁导致python不具备真正意义上的多线程，==建议你使用多进程来处理并发任务==。

python提供的multiprocessing模块可以很好的帮助你实现多进程编程，它提供的接口与多线程模块threading模块十分相似。

在多进程专题中，我会重点讲解使用fork创建子进程，虽然你可以使用multiprocessing轻松的写出多进程程序，但我建议你认真学习使用fork创建子进程，在这个过程中你将学习到父子进程的关系，写时复制这个关键概念。

---

# [Link: 教程|廖雪峰](https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376)

现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统

- 操作系统可以同时运行多个任务

打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。



现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于==CPU执行代码都是顺序执行的==，那么，单核CPU是怎么执行多任务的呢？

- 操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……

- 表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。



真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，==操作系统也会自动把很多任务轮流调度到每个核心上执行==。



## 进程|多任务

对于操作系统来说，一个任务就是一个进程（Process）

- 打开一个浏览器就是启动一个浏览器进程
- 打开一个记事本就启动了一个记事本进程
- 打开两个记事本就启动了两个记事本进程
- 打开一个Word就启动了一个Word进程



## 线程|子任务

有些进程还不止同时干一件事：

- 比如Word，它可以同时进行打字、拼写检查、打印等事情。

在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程(Thread)





每个进程至少要干一件事，所以，一个进程至少有一个线程

像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。

当然，真正地同时执行多线程需要多核CPU才可能实现







# 如何同时执行多个任务？

## 方法1 多进程+单线程

每个进程虽然只有一个线程，但多个进程可以一块执行多个任务





## 方法2 单进程+多线程

启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。





## 方法3 多进程+多线程

这种模型更复杂，实际很少采用。





# 实际应用

同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。

因为复杂度高，调试困难，所以，不是迫不得已，我们也不想编写多任务。



但是，有很多时候，没有多任务还真不行。想想在电脑上看电影，就必须由一个线程播放视频，另一个线程播放音频，否则，单线程实现的话就只能先把视频播放完再播放音频，或者先把音频播放完再播放视频，这显然是不行的。



---

==线程是最小的执行单元==，而进程由至少一个线程组成。

如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。



多进程和多线程的程序涉及到==同步、数据共享==的问题，编写起来更复杂。





# 对比|进程，线程，协程

## 进程和线程

|      | 可以拥有自己的独立资源 | 切换消耗   | 是资源分配单位 | 是执行单元 |
| :--- | :--------------------- | :--------- | :------------- | :--------- |
| 进程 | 可以                   | ==消耗大== | 是             | 否         |
| 线程 | 不可以                 | 消耗小     | 否             | 是         |

进程是资源容器，我们只会说一个进程占用了多少内存，而从来不会说一个线程占用了多少内存。

资源归属于进程，线程却拥有资源的使用权。



==线程的概念是建立在进程的基础上的，一个进程至少有一个主线程，有0个或多个子线程，这些线程共用这个进程所申请的资源，因此才会有线程间同步与资源互斥这些概念==。

由于进程已经是资源分配的单位，因此：

- 进程与进程之间都是相互隔离的，就如同一家一户，各有各的围墙，各有各的宅基地
- 线程如同家庭里的亲人，这些亲人共同使用家里的资源。

本质上，==是线程在执行，进程只是负责申请资源，因此线程才是操作系统调度的最小单位==。

对于操作系统来说：

- 在进程之间进行切换，就如同从一个住宅切换到另一家住宅
- 而在线程间切换，就如同从房子的一间卧室切换到客厅。线程间切换要比进程间切换容易的多。





## 协程

关于协程，要准确掌握以下两个概念

1. ==协程在一个线程中存在==
2. 协程不是系统调度的，而是程序自己负责调度



==协程是线程的异步编程模型==，因此我才说，协程在一个线程中存在，我特意强调一个线程，是想让你明确一点，系统并没有创建出若干个协程来进行工作

在这个线程中，存在多个子程序，假设有子程序A，B，C，那么最初是A在执行，中途遇到了IO，于是停止A，执行B，然后B中也遇到了IO，这个时候再回来执行A，A执行结束后再执行C

会看到，==在一个线程内，A,B,C三个子程序互相协调工作，这个就是协程==。

这里所谓的子程序，你可以理解为函数，但是执行过程又不是函数之间的调用，因为代码里，这三个函数并不存在调用关系，他们可能都是在爬取一个url里的内容，各自的运行是独立的，==但是子程序在执行过程中发生了中断，将控制权交出，在适当的时候返回来继续执行==。@嵌入式：中断





### 协程和线程的对比

线程是系统创建的，具体什么时候执行，执行多久，都是由系统决定的

而==协程则是程序自己创建的，在python中，yield 和gevent都可以实现协程==。



python的多线程由于存在GIL锁，因此一个时刻只有一个线程在运行，如果你起了10个线程，那么CPU要在这10个线程之间不停的切换，每个线程都有自己的一组CPU寄存器，这里保存了线程的上下文，线程之间的切换是会耗费资源的，线程越多，切换的越频繁，耗费的资源也就越多。



协程之间也存在切换，但是==这些协程都是在一个线程中，由程序自身负责切换==，而不是CPU负责切换，这种切换相比于线程之间的切换就快的多了，==协程拥有自己的寄存器上下文和栈==

- 当需要切换时，将这些内容保存到其他地方
- 需要切换回来时，将这些内容回复回来，找到上一次离开时所处的逻辑流位置并继续执行。



线程之间对共享资源的访问必须加锁，但协程不需要，原因很简单，协程始终生存在于一个线程中，根本不存在同时修改一个共享资源的情况。

协程是在线程层面上进行了拆分：

- ==与线程相关的是抢占式多任务==
- ==与协程相关的是协作式多任务==

如果没有协程，当一个线程内遇到IO等待时，会切换到别的线程去执行

但是有了协程，一个线程内的某个子程序遇到IO等待时，会==将控制权==交给同在线程内的其他子程序，没有了线程之间的切换，没有了锁，效率自然变高了。





